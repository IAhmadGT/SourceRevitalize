// STATIC: "CONVERT_TO_SRGB" "0..1"    [ps20b][= g_pHardwareConfig->NeedsShaderSRGBConversion()] [PC]
// STATIC: "CONVERT_TO_SRGB" "0..0"    [= 0] [XBOX]

// DYNAMIC: "MODE" "0..3"
// DYNAMIC: "AUTO_EXPOSURE" "0..1"

#define HDRTYPE HDR_TYPE_NONE
#include "common_ps_fxc.h"

sampler FBSampler : register(s0);

float m_flOverExposure : register(c0);
float m_flUnderExposure : register(c1);
float m_flExposure : register(c2);
float m_flExposureSpeed : register(c3);

struct PS_INPUT
{
    float2 texCoord : TEXCOORD0;
};

float3 toHDR(float3 color)
{
    float3 underExposure = color / m_flUnderExposure;
    float3 overExposure = color * m_flOverExposure;

    float3 hdrImage = lerp(underExposure, overExposure, saturate(color));
    return hdrImage;
}

float3 sRGBCorrect(float3 color)
{
    return pow(color, 1.0f / 2.2f);
}

float3 getExposure(float3 color, float exposure)
{
    float3 retColor = color * exposure;
    return retColor;
}

float3 Burgess(float3 input)
{
    float3 x = max(0, input - 0.004);
    float3 retColor = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);

    return retColor;
}

float3 Reinhard(float3 x)
{
    float3 retColor = x / (x + 1);

    return pow(retColor, 1 / 2.2f);
}

float3 ACES(float3 x)
{
    float a = 2.51f;
    float b = 0.03f;
    float c = 2.43f;
    float d = 0.59f;
    float e = 0.14f;
    float3 retColor = saturate((x * (a * x + b)) / (x * (c * x + d) + e));
    return sRGBCorrect(retColor);
}

float4 main(PS_INPUT i) : COLOR
{
    float3 fbSample = tex2D(FBSampler, i.texCoord).rgb;

    float exposure = m_flExposure;

#if AUTO_EXPOSURE == 1
    // Calculate scene brightness (luminance)
    float luminance = dot(fbSample, float3(0.2126, 0.7152, 0.0722));

    // Use provided registers for auto-exposure calculation
    float targetExposure = m_flExposure;
    float maxChange = m_flOverExposure - m_flUnderExposure;
    float desiredExposure = 1.0 / luminance;

    // Adjust exposure towards the desired exposure
    float exposureDelta = desiredExposure - targetExposure;
    float maxDelta = maxChange * m_flExposureSpeed; // Limit the maximum change based on speed
    float adjustedDelta = clamp(exposureDelta, -maxDelta, maxDelta);
    targetExposure += adjustedDelta;

    // Apply tonemapping based on scene luminance and target exposure
    fbSample *= targetExposure / m_flExposure;

    // Enhance tonemapping effect by applying additional calculations
    float tonemapIntensity = pow(m_flExposure, 2.0) * 0.5; // Complex tonemapping intensity calculation
    fbSample = lerp(fbSample, fbSample * tonemapIntensity, tonemapIntensity);
#endif

    float3 retColor = getExposure(fbSample, exposure);
    retColor = toHDR(retColor);

#if MODE == 1
    retColor = ACES(retColor);
#elif MODE == 2
    retColor = Reinhard(retColor);
#elif MODE == 3
    retColor = Burgess(retColor);
#else
    retColor = sRGBCorrect(retColor);
#endif

    return FinalOutput(float4(retColor, 1.0f), 0, PIXEL_FOG_TYPE_NONE, TONEMAP_SCALE_NONE);
}
