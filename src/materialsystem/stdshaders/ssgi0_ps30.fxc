#define HDRTYPE HDR_TYPE_NONE
#include "common_ps_fxc.h"

// Constants
#define NUM_RAY_SAMPLES 64
#define MAX_DISTANCE 128.0 // Maximum distance to trace rays
#define BLEND_FACTOR 1.0   // Adjust this value to control the strength of the global illumination effect

// Samplers for deferred textures
sampler FBSampler : register(s0); // Framebuffer sampler
sampler DepthSampler : register(s1);
sampler MRAOSampler : register(s2);
sampler NormalSampler : register(s3);
sampler AlbedoSampler : register(s4);

//This is the PS_INPUT that inputs the data
struct PS_INPUT
{
    float2 texCoord : TEXCOORD0;
};

// Function to calculate lighting based on material properties
float3 CalculateMaterialLighting(float3 normal, float3 viewDir, float3 albedo, float3 mraoValues, float metallic, float roughness)
{
    // Simple ambient occlusion from MRAO
    float ambientOcclusion = mraoValues.r;

    // Diffuse term
    float3 diffuseColor = albedo * (1.0 - metallic);

    // Specular term
    float3 specularColor = lerp(float3(0.04, 0.04, 0.04), albedo, metallic);

    // Combine roughness and MRAO for specular intensity
    float specularIntensity = lerp(1.0, 0.5, roughness) * (1.0 - ambientOcclusion);

    // Compute half vector
    float3 halfVec = normalize(viewDir + float3(0.0, 0.0, 1.0));

    // Calculate specular contribution
    float specularFactor = pow(saturate(dot(normal, halfVec)), 128.0) * specularIntensity;

    // Calculate final lighting
    float3 lighting = diffuseColor * ambientOcclusion + specularColor * specularFactor;

    return lighting;
}

// Function to trace a ray and gather illumination
float3 TraceRay(float3 origin, float3 direction)
{
    float3 accumulatedColor = float3(0.0, 0.0, 0.0);
    float t = 0.0;
    
    for (int i = 0; i < NUM_RAY_SAMPLES; ++i)
    {
        float3 rayPosition = origin + t * direction;
        
        // Sample from G-buffer textures
        float3 normal = normalize(tex2D(NormalSampler, rayPosition.xy).xyz * 2.0 - 1.0); // Convert from [0,1] to [-1,1] range
        float3 albedo = tex2D(AlbedoSampler, rayPosition.xy).rgb;
        float3 mraoValues = tex2D(MRAOSampler, rayPosition.xy).rgb;
        float metallic = mraoValues.g;
        float roughness = mraoValues.b;

        // Calculate lighting based on material properties
        float3 lighting = CalculateMaterialLighting(normal, -direction, albedo, mraoValues, metallic, roughness);
        
        // Accumulate color
        accumulatedColor += lighting;
        
        // Move along the ray
        t += 0.1; // Adjust step size as needed
        
        // Break if we reach maximum distance or beyond
        if (t >= MAX_DISTANCE)
            break;
    }
    
    // Average the accumulated color
    return accumulatedColor / float(NUM_RAY_SAMPLES);
}

//This is the main function
float4 main(PS_INPUT i) : COLOR
{
    // Sample from G-buffer textures
    float4 fbColor = tex2D(FBSampler, i.texCoord);
    float depth = tex2D(DepthSampler, i.texCoord).r;

    // Calculate view direction
    float3 viewDir = normalize(float3(i.texCoord, depth) - float3(0.5, 0.5, 0.5));

    // Trace rays for GI
    float3 giColor = TraceRay(fbColor.xyz, viewDir);

    // Blend GI color with framebuffer color
    float3 finalColor = lerp(fbColor.rgb, giColor, BLEND_FACTOR);

    return float4(finalColor, 1.0);
}
